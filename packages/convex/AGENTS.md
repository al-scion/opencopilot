---
globs: packages/convex/**
alwaysApply: false
---

The convex folder is the primary backend of the app. The main schema is in src/convex/schema.ts.
Within the convex folder, the _generated folder should always be ignored, this is generated by the convex cli.
The lib folder is for reusable functions across the backend.
Then there are functional folders for each feature, which is each contain their respective schema and functions.

Workflows can only make use of internal functions on Convex.

## Code Generation

After making changes to the convex, you must run codegen to update the `_generated` types:

```sh
bun run codegen
```

This ensures TypeScript types are up-to-date and the code will typecheck correctly. The generated code in `convex/_generated` should be committed to the repo.

<DOCUMENTATION>
---

### Convex Queries
Title: Queries | Convex Developer Hub

URL Source: http://docs.convex.dev/functions/query-functions

Markdown Content:
Queries are the bread and butter of your backend API. They fetch data from the database, check authentication or perform other business logic, and return data back to the client application.

This is an example query, taking in named arguments, reading data from the database and returning a result:

`import { query } from "./_generated/server";import { v } from "convex/values";// Return the last 100 tasks in a given task list.export const getTaskList = query({  args: { taskListId: v.id("taskLists") },  handler: async (ctx, args) => {    const tasks = await ctx.db      .query("tasks")      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))      .order("desc")      .take(100);    return tasks;  },});`

Read on to understand how to build queries yourself.

Queries are defined in

TypeScript

 files inside your `convex/` directory.
The path and name of the file, as well as the way the function is exported from the file, determine the name the client will use to call it:

`// This function will be referred to as `api.myFunctions.myQuery`.export const myQuery = …;// This function will be referred to as `api.myFunctions.sum`.export const sum = …;`

To structure your API you can nest directories inside the `convex/` directory:

`// This function will be referred to as `api.foo.myQueries.listMessages`.export const listMessages = …;`

Default exports receive the name `default`.

`// This function will be referred to as `api.myFunctions.default`.export default …;`

The same rules apply to [mutations](https://docs.convex.dev/functions/mutation-functions) and [actions](https://docs.convex.dev/functions/actions), while [HTTP actions](https://docs.convex.dev/functions/http-actions) use a different routing approach.

Client libraries in languages other than JavaScript and TypeScript use strings instead of API objects:

*   `api.myFunctions.myQuery` is `"myFunctions:myQuery"`
*   `api.foo.myQueries.myQuery` is `"foo/myQueries:myQuery"`.
*   `api.myFunction.default` is `"myFunction:default"` or `"myFunction"`.

To actually declare a query in Convex you use the `query` constructor function. Pass it an object with a `handler` function, which returns the query result:

`import { query } from "./_generated/server";export const myConstantString = query({  handler: () => {    return "My never changing string";  },});`

### Query arguments[​](http://docs.convex.dev/functions/query-functions#query-arguments "Direct link to Query arguments")

Queries accept named arguments. The argument values are accessible as fields of the second parameter of the handler function:

`import { query } from "./_generated/server";export const sum = query({  handler: (_, args: { a: number; b: number }) => {    return args.a + args.b;  },});`

Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your query.

To both declare the types of arguments and to validate them, add an `args` object using `v` validators:

`import { query } from "./_generated/server";import { v } from "convex/values";export const sum = query({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    return args.a + args.b;  },});`

See [argument validation](https://docs.convex.dev/functions/validation) for the full list of supported types and validators.

The first parameter of the handler function contains the query context.

### Query responses[​](http://docs.convex.dev/functions/query-functions#query-responses "Direct link to Query responses")

Queries can return values of any supported [Convex type](https://docs.convex.dev/functions/validation) which will be automatically serialized and deserialized.

Queries can also return `undefined`, which is not a valid Convex value. When a query returns `undefined`**it is translated to `null`** on the client.

### Query context[​](http://docs.convex.dev/functions/query-functions#query-context "Direct link to Query context")

The `query` constructor enables fetching data, and other Convex features by passing a [QueryCtx](https://docs.convex.dev/generated-api/server#queryctx) object to the handler function as the first parameter:

`import { query } from "./_generated/server";import { v } from "convex/values";export const myQuery = query({  args: { a: v.number(), b: v.number() },  handler: (ctx, args) => {    // Do something with `ctx`  },});`

Which part of the query context is used depends on what your query needs to do:

*   To fetch from the database use the `db` field. Note that we make the handler function an `async` function so we can `await` the promise returned by `db.get()`:

`import { query } from "./_generated/server";import { v } from "convex/values";export const getTask = query({  args: { id: v.id("tasks") },  handler: async (ctx, args) => {    return await ctx.db.get(args.id);  },});` 
Read more about [Reading Data](https://docs.convex.dev/database/reading-data/).

*   To return URLs to stored files use the `storage` field. Read more about [File Storage](https://docs.convex.dev/file-storage).

*   To check user authentication use the `auth` field. Read more about [Authentication](https://docs.convex.dev/auth).

When you want to split up the code in your query or reuse logic across multiple Convex functions you can define and call helper

TypeScript

 functions:

`import { Id } from "./_generated/dataModel";import { query, QueryCtx } from "./_generated/server";import { v } from "convex/values";export const getTaskAndAuthor = query({  args: { id: v.id("tasks") },  handler: async (ctx, args) => {    const task = await ctx.db.get(args.id);    if (task === null) {      return null;    }    return { task, author: await getUserName(ctx, task.authorId ?? null) };  },});async function getUserName(ctx: QueryCtx, userId: Id<"users"> | null) {  if (userId === null) {    return null;  }  return (await ctx.db.get(userId))?.name;}`

You can `export` helpers to use them across multiple files. They will not be callable from outside of your Convex functions.

See [Type annotating server side helpers](https://docs.convex.dev/understanding/best-practices/typescript#type-annotating-server-side-helpers) for more guidance on TypeScript types.

Queries can import NPM packages installed in `node_modules`. Not all NPM packages are supported, see [Runtimes](https://docs.convex.dev/functions/runtimes#default-convex-runtime) for more details.

`npm install @faker-js/faker`

`import { query } from "./_generated/server";import { faker } from "@faker-js/faker";export const randomName = query({  args: {},  handler: () => {    faker.seed();    return faker.person.fullName();  },});`

To call a query from [React](https://docs.convex.dev/client/react) use the [`useQuery`](https://docs.convex.dev/client/react#fetching-data) hook along with the generated [`api`](https://docs.convex.dev/generated-api/api) object.

`import { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function MyApp() {  const data = useQuery(api.myFunctions.sum, { a: 1, b: 2 });  // do something with `data`}`

See the [React](https://docs.convex.dev/client/react) client documentation for all the ways queries can be called.

Queries have three awesome attributes:

1.   **Caching**: Convex caches query results automatically. If many clients request the same query, with the same arguments, they will receive a cached response.
2.   **Reactivity**: clients can subscribe to queries to receive new results when the underlying data changes.
3.   **Consistency**: All database reads inside a single query call are performed at the same logical timestamp. Concurrent writes do not affect the query results.

To have these attributes the handler function must be _deterministic_, which means that given the same arguments (including the query context) it will return the same response.

For this reason queries cannot `fetch` from third party APIs. To call third party APIs, use [actions](https://docs.convex.dev/functions/actions).

You might wonder whether you can use non-deterministic language functionality like `Math.random()` or `Date.now()`. The short answer is that Convex takes care of implementing these in a way that you don't have to think about the deterministic constraint.

See [Runtimes](https://docs.convex.dev/functions/runtimes#default-convex-runtime) for more details on the Convex runtime.

Queries have a limit to the amount of data they can read at once to guarantee good performance. Check out these limits in [Read/write limit errors](https://docs.convex.dev/functions/error-handling/#readwrite-limit-errors).

For information on other limits, see [Limits](https://docs.convex.dev/production/state/limits).


--- 

Title: Mutations | Convex Developer Hub

URL Source: https://docs.convex.dev/functions/mutation-functions

Markdown Content:
Mutations insert, update and remove data from the database, check authentication or perform other business logic, and optionally return a response to the client application.

This is an example mutation, taking in named arguments, writing data to the database and returning a result:

`import { mutation } from "./_generated/server";import { v } from "convex/values";// Create a new task with the given textexport const createTask = mutation({  args: { text: v.string() },  handler: async (ctx, args) => {    const newTaskId = await ctx.db.insert("tasks", { text: args.text });    return newTaskId;  },});`

Read on to understand how to build mutations yourself.

Mutations follow the same naming rules as queries, see [Query names](https://docs.convex.dev/functions/query-functions#query-names).

Queries and mutations can be defined in the same file when using named exports.

To declare a mutation in Convex use the `mutation` constructor function. Pass it an object with a `handler` function, which performs the mutation:

`import { mutation } from "./_generated/server";export const mutateSomething = mutation({  handler: () => {    // implementation will be here  },});`

Unlike a query, a mutation can but does not have to return a value.

### Mutation arguments[​](https://docs.convex.dev/functions/mutation-functions#mutation-arguments "Direct link to Mutation arguments")

Just like queries, mutations accept named arguments, and the argument values are accessible as fields of the second parameter of the `handler` function:

`import { mutation } from "./_generated/server";export const mutateSomething = mutation({  handler: (_, args: { a: number; b: number }) => {    // do something with `args.a` and `args.b`    // optionally return a value    return "success";  },});`

Arguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your mutation.

To both declare the types of arguments and to validate them, add an `args` object using `v` validators:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const mutateSomething = mutation({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    // do something with `args.a` and `args.b`  },});`

See [argument validation](https://docs.convex.dev/functions/validation) for the full list of supported types and validators.

The first parameter to the handler function is reserved for the mutation context.

### Mutation responses[​](https://docs.convex.dev/functions/mutation-functions#mutation-responses "Direct link to Mutation responses")

Queries can return values of any supported [Convex type](https://docs.convex.dev/functions/validation) which will be automatically serialized and deserialized.

Mutations can also return `undefined`, which is not a valid Convex value. When a mutation returns `undefined`**it is translated to `null`** on the client.

### Mutation context[​](https://docs.convex.dev/functions/mutation-functions#mutation-context "Direct link to Mutation context")

The `mutation` constructor enables writing data to the database, and other Convex features by passing a [MutationCtx](https://docs.convex.dev/generated-api/server#mutationctx) object to the handler function as the first parameter:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const mutateSomething = mutation({  args: { a: v.number(), b: v.number() },  handler: (ctx, args) => {    // Do something with `ctx`  },});`

Which part of the mutation context is used depends on what your mutation needs to do:

*   To read from and write to the database use the `db` field. Note that we make the handler function an `async` function so we can `await` the promise returned by `db.insert()`:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const addItem = mutation({  args: { text: v.string() },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });  },});` 
Read on about [Writing Data](https://docs.convex.dev/database/writing-data).

*   To generate upload URLs for storing files use the `storage` field. Read on about [File Storage](https://docs.convex.dev/file-storage).

*   To check user authentication use the `auth` field. Read on about [Authentication](https://docs.convex.dev/auth).

*   To schedule functions to run in the future, use the `scheduler` field. Read on about [Scheduled Functions](https://docs.convex.dev/scheduling/scheduled-functions).

When you want to split up the code in your mutation or reuse logic across multiple Convex functions you can define and call helper

TypeScript

functions:

`import { v } from "convex/values";import { mutation, MutationCtx } from "./_generated/server";export const addItem = mutation({  args: { text: v.string() },  handler: async (ctx, args) => {    await ctx.db.insert("tasks", { text: args.text });    await trackChange(ctx, "addItem");  },});async function trackChange(ctx: MutationCtx, type: "addItem" | "removeItem") {  await ctx.db.insert("changes", { type });}`

Mutations can call helpers that take a [QueryCtx](https://docs.convex.dev/generated-api/server#queryctx) as argument, since the mutation context can do everything query context can.

You can `export` helpers to use them across multiple files. They will not be callable from outside of your Convex functions.

See [Type annotating server side helpers](https://docs.convex.dev/understanding/best-practices/typescript#type-annotating-server-side-helpers) for more guidance on TypeScript types.

Mutations can import NPM packages installed in `node_modules`. Not all NPM packages are supported, see [Runtimes](https://docs.convex.dev/functions/runtimes#default-convex-runtime) for more details.

`npm install @faker-js/faker`

`import { faker } from "@faker-js/faker";import { mutation } from "./_generated/server";export const randomName = mutation({  args: {},  handler: async (ctx) => {    faker.seed();    await ctx.db.insert("tasks", { text: "Greet " + faker.person.fullName() });  },});`

To call a mutation from [React](https://docs.convex.dev/client/react) use the [`useMutation`](https://docs.convex.dev/client/react#editing-data) hook along with the generated [`api`](https://docs.convex.dev/generated-api/api) object.

`import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";export function MyApp() {  const mutateSomething = useMutation(api.myFunctions.mutateSomething);  const handleClick = () => {    mutateSomething({ a: 1, b: 2 });  };  // pass `handleClick` to a button  // ...}`

See the [React](https://docs.convex.dev/client/react) client documentation for all the ways queries can be called.

When mutations are called from the [React](https://docs.convex.dev/client/react) or [Rust](https://docs.convex.dev/client/rust) clients, they are executed one at a time in a single, ordered queue. You don't have to worry about mutations editing the database in a different order than they were triggered.

Mutations run **transactionally**. This means that:

1.   All database reads inside the transaction get a consistent view of the data in the database. You don't have to worry about a concurrent update changing the data in the middle of the execution.
2.   All database writes get committed together. If the mutation writes some data to the database, but later throws an error, no data is actually written to the database.

For this to work, similarly to queries, mutations must be deterministic, and cannot call third party APIs. To call third party APIs, use [actions](https://docs.convex.dev/functions/actions).

Mutations have a limit to the amount of data they can read and write at once to guarantee good performance. Learn more in [Read/write limit errors](https://docs.convex.dev/functions/error-handling/#readwrite-limit-errors).

For information on other limits, see [Limits](https://docs.convex.dev/production/state/limits).

---

Title: Actions | Convex Developer Hub

URL Source: https://docs.convex.dev/functions/actions

Markdown Content:
Actions can call third party services to do things such as processing a payment with [Stripe](https://stripe.com/). They can be run in Convex's JavaScript environment or in Node.js. They can interact with the database indirectly by calling [queries](https://docs.convex.dev/functions/query-functions) and [mutations](https://docs.convex.dev/functions/mutation-functions).

**Example:**[GIPHY Action](https://github.com/get-convex/convex-demos/tree/main/giphy-action)

Actions follow the same naming rules as queries, see [Query names](https://docs.convex.dev/functions/query-functions#query-names).

To declare an action in Convex you use the action constructor function. Pass it an object with a `handler` function, which performs the action:

`import { action } from "./_generated/server";export const doSomething = action({  handler: () => {    // implementation goes here    // optionally return a value    return "success";  },});`

Unlike a query, an action can but does not have to return a value.

### Action arguments and responses[​](https://docs.convex.dev/functions/actions#action-arguments-and-responses "Direct link to Action arguments and responses")

Action arguments and responses follow the same rules as [mutations](https://docs.convex.dev/functions/mutation-functions#mutation-arguments):

`import { action } from "./_generated/server";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number(), b: v.number() },  handler: (_, args) => {    // do something with `args.a` and `args.b`    // optionally return a value    return "success";  },});`

The first argument to the handler function is reserved for the action context.

### Action context[​](https://docs.convex.dev/functions/actions#action-context "Direct link to Action context")

The `action` constructor enables interacting with the database, and other Convex features by passing an [ActionCtx](https://docs.convex.dev/api/interfaces/server.GenericActionCtx) object to the handler function as the first argument:

`import { action } from "./_generated/server";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number(), b: v.number() },  handler: (ctx, args) => {    // do something with `ctx`  },});`

Which part of that action context is used depends on what your action needs to do:

*   To read data from the database use the `runQuery` field, and call a query that performs the read:

`import { action, internalQuery } from "./_generated/server";import { internal } from "./_generated/api";import { v } from "convex/values";export const doSomething = action({  args: { a: v.number() },  handler: async (ctx, args) => {    const data = await ctx.runQuery(internal.myFunctions.readData, {      a: args.a,    });    // do something with `data`  },});export const readData = internalQuery({  args: { a: v.number() },  handler: async (ctx, args) => {    // read from `ctx.db` here  },});` 
Here `readData` is an [internal query](https://docs.convex.dev/functions/internal-functions) because we don't want to expose it to the client directly. Actions, mutations and queries can be defined in the same file.

*   To write data to the database use the `runMutation` field, and call a mutation that performs the write:

`import { v } from "convex/values";import { action } from "./_generated/server";import { internal } from "./_generated/api";export const doSomething = action({  args: { a: v.number() },  handler: async (ctx, args) => {    const data = await ctx.runMutation(internal.myMutations.writeData, {      a: args.a,    });    // do something else, optionally use `data`  },});` 
Use an [internal mutation](https://docs.convex.dev/functions/internal-functions) when you want to prevent users from calling the mutation directly.

As with queries, it's often convenient to define actions and mutations in the same file.

*   To generate upload URLs for storing files use the `storage` field. Read on about [File Storage](https://docs.convex.dev/file-storage).

*   To check user authentication use the `auth` field. Auth is propagated automatically when calling queries and mutations from the action. Read on about [Authentication](https://docs.convex.dev/auth).

*   To schedule functions to run in the future, use the `scheduler` field. Read on about [Scheduled Functions](https://docs.convex.dev/scheduling/scheduled-functions).

*   To search a vector index, use the `vectorSearch` field. Read on about [Vector Search](https://docs.convex.dev/search/vector-search).

### Dealing with circular type inference[​](https://docs.convex.dev/functions/actions#dealing-with-circular-type-inference "Direct link to Dealing with circular type inference")

Working around the TypeScript error: some action `implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.`

Actions can run in Convex's custom JavaScript environment or in Node.js.

By default, actions run in Convex's environment. This environment supports `fetch`, so actions that simply want to call a third-party API using `fetch` can be run in this environment:

`import { action } from "./_generated/server";export const doSomething = action({  args: {},  handler: async () => {    const data = await fetch("https://api.thirdpartyservice.com");    // do something with data  },});`

Actions running in Convex's environment are faster compared to Node.js, since they don't require extra time to start up before running your action (cold starts). They can also be defined in the same file as other Convex functions. Like queries and mutations they can import NPM packages, but not all are supported.

Actions needing unsupported NPM packages or Node.js APIs can be configured to run in Node.js by adding the `"use node"` directive at the top of the file. Note that other Convex functions cannot be defined in files with the `"use node";` directive.

`"use node";import { action } from "./_generated/server";import SomeNpmPackage from "some-npm-package";export const doSomething = action({  args: {},  handler: () => {    // do something with SomeNpmPackage  },});`

Learn more about the two [Convex Runtimes](https://docs.convex.dev/functions/runtimes).

Just like with [queries](https://docs.convex.dev/functions/query-functions#splitting-up-query-code-via-helpers) and [mutations](https://docs.convex.dev/functions/mutation-functions#splitting-up-mutation-code-via-helpers) you can define and call helper

TypeScript

 functions to split up the code in your actions or reuse logic across multiple Convex functions.
But note that the [ActionCtx](https://docs.convex.dev/api/interfaces/server.GenericActionCtx) only has the `auth` field in common with [QueryCtx](https://docs.convex.dev/generated-api/server#queryctx) and [MutationCtx](https://docs.convex.dev/generated-api/server#mutationctx).

To call an action from [React](https://docs.convex.dev/client/react) use the [`useAction`](https://docs.convex.dev/api/modules/react#useaction) hook along with the generated [`api`](https://docs.convex.dev/generated-api/api) object.

`import { useAction } from "convex/react";import { api } from "../convex/_generated/api";export function MyApp() {  const performMyAction = useAction(api.myFunctions.doSomething);  const handleClick = () => {    performMyAction({ a: 1 });  };  // pass `handleClick` to a button  // ...}`

Unlike [mutations](https://docs.convex.dev/functions/mutation-functions#calling-mutations-from-clients), actions from a single client are parallelized. Each action will be executed as soon as it reaches the server (even if other actions and mutations from the same client are running). If your app relies on actions running after other actions or mutations, make sure to only trigger the action after the relevant previous function completes.

**Note:** In most cases calling an action directly from a client **is an anti-pattern**. Instead, have the client call a [mutation](https://docs.convex.dev/functions/mutation-functions) which captures the user intent by writing into the database and then [schedules](https://docs.convex.dev/scheduling/scheduled-functions) an action:

`import { v } from "convex/values";import { internal } from "./_generated/api";import { internalAction, mutation } from "./_generated/server";export const mutationThatSchedulesAction = mutation({  args: { text: v.string() },  handler: async (ctx, { text }) => {    const taskId = await ctx.db.insert("tasks", { text });    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {      taskId,      text,    });  },});export const actionThatCallsAPI = internalAction({  args: { taskId: v.id("tasks"), text: v.string() },  handler: (_, args): void => {    // do something with `taskId` and `text`, like call an API    // then run another mutation to store the result  },});`

This way the mutation can enforce invariants, such as preventing the user from executing the same action twice.

Actions time out after 10 minutes. [Node.js](https://docs.convex.dev/functions/runtimes#nodejs-runtime) and [Convex runtime](https://docs.convex.dev/functions/runtimes#default-convex-runtime) have 512MB and 64MB memory limit respectively. Please [contact us](https://docs.convex.dev/production/contact) if you have a use case that requires configuring higher limits.

Actions can do up to 1000 concurrent operations, such as executing queries, mutations or performing fetch requests.

For information on other limits, see [here](https://docs.convex.dev/production/state/limits).

Unlike queries and mutations, actions may have side-effects and therefore can't be automatically retried by Convex when errors occur. For example, say your action calls Stripe to send a customer invoice. If the HTTP request fails, Convex has no way of knowing if the invoice was already sent. Like in normal backend code, it is the responsibility of the caller to handle errors raised by actions and retry the action call if appropriate.

Make sure to await all promises created within an action. Async tasks still running when the function returns might or might not complete. In addition, since the Node.js execution environment might be reused between action calls, dangling promises might result in errors in subsequent action invocations.

### `await ctx.runAction` should only be used for crossing JS runtimes[​](https://docs.convex.dev/functions/actions#await-ctxrunaction-should-only-be-used-for-crossing-js-runtimes "Direct link to await-ctxrunaction-should-only-be-used-for-crossing-js-runtimes")

**Why?**`await ctx.runAction` incurs to overhead of another Convex server function. It counts as an extra function call, it allocates its own system resources, and while you're awaiting this call the parent action call is frozen holding all it's resources. If you pile enough of these calls on top of each other, your app may slow down significantly.

**Fix:** The reason this api exists is to let you run code in the [Node.js environment](https://docs.convex.dev/functions/runtimes). If you want to call an action from another action that's in the same runtime, which is the normal case, the best way to do this is to pull the code you want to call into a TypeScript [helper function](https://docs.convex.dev/understanding/best-practices/#use-helper-functions-to-write-shared-code) and call the helper instead.

### Avoid `await ctx.runMutation` / `await ctx.runQuery`[​](https://docs.convex.dev/functions/actions#avoid-await-ctxrunmutation--await-ctxrunquery "Direct link to avoid-await-ctxrunmutation--await-ctxrunquery")

`// ❌const foo = await ctx.runQuery(...)const bar = await ctx.runQuery(...)// ✅const fooAndBar = await ctx.runQuery(...)`

**Why?** Multiple runQuery / runMutations execute in separate transactions and aren't guaranteed to be consistent with each other (e.g. foo and bar could read the same document and return two different results), while a single runQuery / runMutation will always be consistent. Additionally, you're paying for multiple function calls when you don't have to.

**Fix:** Make a new internal query / mutation that does both things. Refactoring the code for the two functions into helpers will make it easy to create a new internal function that does both things while still keeping around the original functions. Potentially try and refactor your action code to "batch" all the database access.

Caveats: Separate runQuery / runMutation calls are valid when intentionally trying to process more data than fits in a single transaction (e.g. running a migration, doing a live aggregate).

--- 
Title: Indexes | Convex Developer Hub

URL Source: https://docs.convex.dev/database/reading-data/indexes/

Markdown Content:
Indexes are a data structure that allow you to speed up your [document queries](https://docs.convex.dev/database/reading-data/#querying-documents) by telling Convex how to organize your documents. Indexes also allow you to change the order of documents in query results.

For a more in-depth introduction to indexing see [Indexes and Query Performance](https://docs.convex.dev/database/reading-data/indexes/indexes-and-query-perf).

Indexes are defined as part of your Convex [schema](https://docs.convex.dev/database/schemas). Each index consists of:

1.   A name.
    *   Must be unique per table.

2.   An ordered list of fields to index.
    *   To specify a field on a nested document, use a dot-separated path like `properties.name`.

To add an index onto a table, use the [`index`](https://docs.convex.dev/api/classes/server.TableDefinition#index) method on your table's schema:

convex/schema.ts

`import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";// Define a messages table with two indexes.export default defineSchema({  messages: defineTable({    channel: v.id("channels"),    body: v.string(),    user: v.id("users"),  })    .index("by_channel", ["channel"])    .index("by_channel_user", ["channel", "user"]),});`

The `by_channel` index is ordered by the `channel` field defined in the schema. For messages in the same channel, they are ordered by the [system-generated `_creationTime` field](https://docs.convex.dev/database/types#system-fields) which is added to all indexes automatically.

By contrast, the `by_channel_user` index orders messages in the same `channel` by the `user` who sent them, and only then by `_creationTime`.

Indexes are created in [`npx convex dev`](https://docs.convex.dev/cli#run-the-convex-dev-server) and [`npx convex deploy`](https://docs.convex.dev/cli#deploy-convex-functions-to-production).

You may notice that the first deploy that defines an index is a bit slower than normal. This is because Convex needs to _backfill_ your index. The more data in your table, the longer it will take Convex to organize it in index order. If this is problematic for your workflow, [contact us](https://docs.convex.dev/production/contact).

You can feel free to query an index in the same deploy that defines it. Convex will ensure that the index is backfilled before the new query and mutation functions are registered.

Be careful when removing indexes

In addition to adding new indexes, `npx convex deploy` will delete indexes that are no longer present in your schema. Make sure that your indexes are completely unused before removing them from your schema!

A query for "messages in `channel` created 1-2 minutes ago" over the `by_channel` index would look like:

`const messages = await ctx.db  .query("messages")  .withIndex("by_channel", (q) =>    q      .eq("channel", channel)      .gt("_creationTime", Date.now() - 2 * 60000)      .lt("_creationTime", Date.now() - 60000),  )  .collect();`

The [`.withIndex`](https://docs.convex.dev/api/interfaces/server.QueryInitializer#withindex) method defines which index to query and how Convex will use that index to select documents. The first argument is the name of the index and the second is an _index range expression_. An index range expression is a description of which documents Convex should consider when running the query.

The choice of index both affects how you write the index range expression and what order the results are returned in. For instance, by making both a `by_channel` and `by_channel_user` index, we can get results within a channel ordered by `_creationTime` or by `user`, respectively. If you were to use the `by_channel_user` index like this:

`const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) => q.eq("channel", channel))  .collect();`

The results would be all of the messages in a `channel` ordered by `user`, then by `_creationTime`. If you were to use `by_channel_user` like this:

`const messages = await ctx.db  .query("messages")  .withIndex("by_channel_user", (q) =>    q.eq("channel", channel).eq("user", user),  )  .collect();`

The results would be the messages in the given `channel` sent by `user`, ordered by `_creationTime`.

An index range expression is always a chained list of:

1.   0 or more equality expressions defined with [`.eq`](https://docs.convex.dev/api/interfaces/server.IndexRangeBuilder#eq).
2.   [Optionally] A lower bound expression defined with [`.gt`](https://docs.convex.dev/api/interfaces/server.IndexRangeBuilder#gt) or [`.gte`](https://docs.convex.dev/api/interfaces/server.IndexRangeBuilder#gte).
3.   [Optionally] An upper bound expression defined with [`.lt`](https://docs.convex.dev/api/interfaces/server.IndexRangeBuilder#lt) or [`.lte`](https://docs.convex.dev/api/interfaces/server.IndexRangeBuilder#lte).

**You must step through fields in index order.**

Each equality expression must compare a different index field, starting from the beginning and in order. The upper and lower bounds must follow the equality expressions and compare the next field.

For example, it is not possible to write a query like:

`// DOES NOT COMPILE!const messages = await ctx.db  .query("messages")  .withIndex("by_channel", (q) =>    q      .gt("_creationTime", Date.now() - 2 * 60000)      .lt("_creationTime", Date.now() - 60000),  )  .collect();`

This query is invalid because the `by_channel` index is ordered by `(channel, _creationTime)` and this query range has a comparison on `_creationTime` without first restricting the range to a single `channel`. Because the index is sorted first by `channel` and then by `_creationTime`, it isn't a useful index for finding messages in all channels created 1-2 minutes ago. The TypeScript types within `withIndex` will guide you through this.

To better understand what queries can be run over which indexes, see [Introduction to Indexes and Query Performance](https://docs.convex.dev/database/reading-data/indexes/indexes-and-query-perf).

**The performance of your query is based on the specificity of the range.**

For example, if the query is

`const messages = await ctx.db  .query("messages")  .withIndex("by_channel", (q) =>    q      .eq("channel", channel)      .gt("_creationTime", Date.now() - 2 * 60000)      .lt("_creationTime", Date.now() - 60000),  )  .collect();`

then query's performance would be based on the number of messages in `channel` created 1-2 minutes ago.

If the index range is not specified, all documents in the index will be considered in the query.

Picking a good index range

For performance, define index ranges that are as specific as possible! If you are querying a large table and you're unable to add any equality conditions with `.eq`, you should consider defining a new index.

`.withIndex` is designed to only allow you to specify ranges that Convex can efficiently use your index to find. For all other filtering you can use the [`.filter`](https://docs.convex.dev/api/interfaces/server.Query#filter) method.

For example to query for "messages in `channel`**not** created by me" you could do:

`const messages = await ctx.db  .query("messages")  .withIndex("by_channel", q => q.eq("channel", channel))  .filter(q => q.neq(q.field("user"), myUserId)  .collect();`

In this case the performance of this query will be based on how many messages are in the channel. Convex will consider each message in the channel and only return the messages where the `user` field matches `myUserId`.

Queries that use `withIndex` are ordered by the columns specified in the index.

The order of the columns in the index dictates the priority for sorting. The values of the columns listed first in the index are compared first. Subsequent columns are only compared as tie breakers only if all earlier columns match.

Since Convex automatically includes `_creationTime` as the last column in all indexes, `_creationTime` will always be the final tie breaker if all other columns in the index are equal.

For example, `by_channel_user` includes `channel`, `user`, and `\_creationTime`. So queries on `messages` that use `.withIndex("by_channel_user")` will be sorted first by channel, then by user within each channel, and finally by the creation time.

Sorting with indexes allows you to satisfy use cases like displaying the top `N` scoring users, the most recent `N` transactions, or the most `N` liked messages.

For example, to get the top 10 highest scoring players in your game, you might define an index on the player's highest score:

`export default defineSchema({  players: defineTable({    username: v.string(),    highestScore: v.number(),  }).index("by_highest_score", ["highestScore"]),});`

You can then efficiently find the top 10 highest scoring players using your index and [`take(10)`](https://docs.convex.dev/api/interfaces/server.Query#take):

`const topScoringPlayers = await ctx.db  .query("users")  .withIndex("by_highest_score")  .order("desc")  .take(10);`

In this example, the range expression is omitted because we're looking for the highest scoring players of all time. This particular query is reasonably efficient for large data sets only because we're using `take()`.

If you use an index without a range expression, you should always use one of the following in conjunction with `withIndex`:

1.   [`.first()`](https://docs.convex.dev/api/interfaces/server.Query#first)
2.   [`.unique()`](https://docs.convex.dev/api/interfaces/server.Query#unique)
3.   [`.take(n)`](https://docs.convex.dev/api/interfaces/server.Query#take)
4.   [`.paginate(ops)`](https://docs.convex.dev/database/pagination)

These APIs allow you to efficiently limit your query to a reasonable size without performing a full table scan.

Full Table Scans

When your query fetches documents from the database, it will scan the rows in the range you specify. If you are using `.collect()`, for instance, it will scan all of the rows in the range. So if you use `withIndex` without a range expression, you will be [scanning the whole table](https://docs.convex.dev/database/indexes/indexes-and-query-perf#full-table-scans), which can be slow when your table has thousands of rows. `.filter()` doesn't affect which documents are scanned. Using `.first()` or `.unique()` or `.take(n)` will only scan rows until it has enough documents.

You can include a range expression to satisfy more targeted queries. For example, to get the top scoring players in Canada, you might use both `take()` and a range expression:

`// query the top 10 highest scoring players in Canada.const topScoringPlayers = await ctx.db  .query("users")  .withIndex("by_country_highest_score", (q) => q.eq("country", "CA"))  .order("desc")  .take(10);`

Convex supports indexes containing up to 16 fields. You can define 32 indexes on each table. Indexes can't contain duplicate fields.

No reserved fields (starting with `_`) are allowed in indexes. The `_creationTime` field is automatically added to the end of every index to ensure a stable ordering. It should not be added explicitly in the index definition, and it's counted towards the index fields limit.

The `by_creation_time` index is created automatically (and is what is used in database queries that don't specify an index). The `by_id` index is reserved.

---

Title: Filters | Convex Developer Hub

URL Source: https://docs.convex.dev/database/reading-data/filters

Markdown Content:
Filtering
---------

The [`filter`](https://docs.convex.dev/api/interfaces/server.Query#filter) method allows you to restrict the documents that your document query returns. This method takes a filter constructed by [`FilterBuilder`](https://docs.convex.dev/api/interfaces/server.FilterBuilder) and will only select documents that match.

The examples below demonstrate some of the common uses of `filter`. You can see the full list of available filtering methods [in the reference docs](https://docs.convex.dev/api/interfaces/server.FilterBuilder).

If you need to filter to documents containing some keywords, use a [search query](https://docs.convex.dev/search/text-search).

Use indexes instead

Filters effectively loop over your table looking for documents that match. This can be slow or cause your function to hit a [limit](https://docs.convex.dev/production/state/limits) when your table has thousands of rows. For faster more database efficient queries use [indexes instead](https://docs.convex.dev/database/reading-data/indexes/).

### Equality conditions[​](https://docs.convex.dev/database/reading-data/filters#equality-conditions "Direct link to Equality conditions")

This document query finds documents in the `users` table where `doc.name === "Alex"`:

`// Get all users named "Alex".const usersNamedAlex = await ctx.db  .query("users")  .filter((q) => q.eq(q.field("name"), "Alex"))  .collect();`

Here `q` is the [`FilterBuilder`](https://docs.convex.dev/api/interfaces/server.FilterBuilder) utility object. It contains methods for all of our supported filter operators.

This filter will run on all documents in the table. For each document, `q.field("name")` evaluates to the `name` property. Then `q.eq` checks if this property is equal to `"Alex"`.

If your query references a field that is missing from a given document then that field will be considered to have the value `undefined`.

### Comparisons[​](https://docs.convex.dev/database/reading-data/filters#comparisons "Direct link to Comparisons")

Filters can also be used to compare fields against values. This document query finds documents where `doc.age >= 18`:

`// Get all users with an age of 18 or higher.const adults = await ctx.db  .query("users")  .filter((q) => q.gte(q.field("age"), 18))  .collect();`

Here the `q.gte` operator checks if the first argument (`doc.age`) is greater than or equal to the second (`18`).

Here's the full list of comparisons:

| Operator | Equivalent TypeScript |
| --- | --- |
| `q.eq(l, r)` | `l === r` |
| `q.neq(l, r)` | `l !== r` |
| `q.lt(l, r)` | `l < r` |
| `q.lte(l, r)` | `l <= r` |
| `q.gt(l, r)` | `l > r` |
| `q.gte(l, r)` | `l >= r` |

### Arithmetic[​](https://docs.convex.dev/database/reading-data/filters#arithmetic "Direct link to Arithmetic")

You can also include basic arithmetic in your queries. This document query finds documents in the `carpets` table where `doc.height * doc.width > 100`:

`// Get all carpets that have an area of over 100.const largeCarpets = await ctx.db  .query("carpets")  .filter((q) => q.gt(q.mul(q.field("height"), q.field("width")), 100))  .collect();`

Here's the full list of arithmetic operators:

| Operator | Equivalent TypeScript |
| --- | --- |
| `q.add(l, r)` | `l + r` |
| `q.sub(l, r)` | `l - r` |
| `q.mul(l, r)` | `l * r` |
| `q.div(l, r)` | `l / r` |
| `q.mod(l, r)` | `l % r` |
| `q.neg(x)` | `-x` |

### Combining operators[​](https://docs.convex.dev/database/reading-data/filters#combining-operators "Direct link to Combining operators")

You can construct more complex filters using methods like `q.and`, `q.or`, and `q.not`. This document query finds documents where `doc.name === "Alex" && doc.age >= 18`:

`// Get all users named "Alex" whose age is at least 18.const adultAlexes = await ctx.db  .query("users")  .filter((q) =>    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18)),  )  .collect();`

Here is a query that finds all users where `doc.name === "Alex" || doc.name === "Emma"`:

`// Get all users named "Alex" or "Emma".const usersNamedAlexOrEmma = await ctx.db  .query("users")  .filter((q) =>    q.or(q.eq(q.field("name"), "Alex"), q.eq(q.field("name"), "Emma")),  )  .collect();`

Sometimes the filter syntax is is not expressive enough. For example you may want to collect all posts that have a tag. Your schema for the posts looks like this:

`export default defineSchema({  posts: defineTable({    body: v.string(),    tags: v.array(v.string()),  }),});`

One way to solve is by applying the filter on the result of the `collect()` call. This is just filtering a JavaScript array:

`export const postsWithTag = query({  args: { tag: v.string() },  handler: async (ctx, args) => {    const allPosts = await ctx.db.query("posts").collect();    return allPosts.filter((post) => post.tags.includes(args.tag));  },});`

But this requires reading the whole table first. If you want to just get the first result that matches, reading the whole table could be very inefficient. Instead you may want to use the JavaScript [`for await...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) syntax to loop through the table one document at a time:

`export const firstPostWithTag = query({  args: { tag: v.string() },  handler: (ctx, args) => {    for await (const post of db.query("posts")) {      if (post.tags.includes(args.tag)) {        return post;      }    }  },});`

This works because Convex queries are [JavaScript iterables](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).

Even with this optimization you are still just looping over the table to find the first post that matches and may hit your function limits. Using indexes is still the way to go. You can read a [detailed discussion of how to handle tags with indexes](https://stack.convex.dev/complex-filters-in-convex#optimize-with-indexes).

Most of the example document queries above can lead to a _full table scan_. That is, for the document query to return the requested results, it might need to walk over every single document in the table.

Take this simple example:

`const tasks = await ctx.db.query("tasks").take(5);`

This document query will not scan more than 5 documents.

On the other hand, this document query:

`const tasks = await ctx.db  .query("tasks")  .filter((q) => q.eq(q.field("isCompleted"), true))  .first();`

might need to walk over every single document in the `"tasks"` table just to find the first one with `isCompleted: true`.

If a table has more than a few thousand documents, you should use [indexes](https://docs.convex.dev/database/reading-data/indexes/) to improve your document query performance. Otherwise, you may run into our enforced limits, detailed in [Read/write limit errors](https://docs.convex.dev/functions/error-handling/#readwrite-limit-errors).

For information on other limits, see [Limits](https://docs.convex.dev/production/state/limits).

---

Title: Schemas | Convex Developer Hub

URL Source: https://docs.convex.dev/database/schemas

Markdown Content:
A schema is a description of

1.   the tables in your Convex project
2.   the type of documents within your tables

While it is possible to use Convex _without_ defining a schema, adding a `schema.ts` file will ensure that the documents in your tables are the correct type. If you're using [TypeScript](https://docs.convex.dev/understanding/best-practices/typescript), adding a schema will also give you end-to-end type safety throughout your app.

We recommend beginning your project without a schema for rapid prototyping and then adding a schema once you've solidified your plan. To learn more see our [Schema Philosophy](https://docs.convex.dev/database/advanced/schema-philosophy).

**Example:**[TypeScript and Schemas](https://github.com/get-convex/convex-demos/tree/main/typescript)

Schemas are defined in a `schema.ts` file in your `convex/` directory and look like:

convex/schema.ts

`import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  messages: defineTable({    body: v.string(),    user: v.id("users"),  }),  users: defineTable({    name: v.string(),    tokenIdentifier: v.string(),  }).index("by_token", ["tokenIdentifier"]),});`

This schema (which is based on our [users and auth example](https://github.com/get-convex/convex-demos/tree/main/users-and-auth)), has 2 tables: messages and users. Each table is defined using the [`defineTable`](https://docs.convex.dev/api/modules/server#definetable) function. Within each table, the document type is defined using the validator builder, [`v`](https://docs.convex.dev/api/modules/values#v). In addition to the fields listed, Convex will also automatically add `_id` and `_creationTime` fields. To learn more, see [System Fields](https://docs.convex.dev/database/types#system-fields).

Generating a Schema

While writing your schema, it can be helpful to consult the [Convex Dashboard](https://docs.convex.dev/dashboard/deployments/data#generating-a-schema). The "Generate Schema" button in the "Data" view suggests a schema declaration based on the data in your tables.

### Validators[​](https://docs.convex.dev/database/schemas#validators "Direct link to Validators")

The validator builder, [`v`](https://docs.convex.dev/api/modules/values#v) is used to define the type of documents in each table. It has methods for each of [Convex's types](https://docs.convex.dev/database/types):

convex/schema.ts

`import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  documents: defineTable({    id: v.id("documents"),    string: v.string(),    number: v.number(),    boolean: v.boolean(),    nestedObject: v.object({      property: v.string(),    }),  }),});`

It additionally allows you to define unions, optional property, string literals, and more. [Argument validation](https://docs.convex.dev/functions/validation) and schemas both use the same validator builder, `v`.

#### Optional fields[​](https://docs.convex.dev/database/schemas#optional-fields "Direct link to Optional fields")

You can describe optional fields by wrapping their type with `v.optional(...)`:

`defineTable({  optionalString: v.optional(v.string()),  optionalNumber: v.optional(v.number()),});`

This corresponds to marking fields as optional with `?` in TypeScript.

#### Unions[​](https://docs.convex.dev/database/schemas#unions "Direct link to Unions")

You can describe fields that could be one of multiple types using `v.union`:

`defineTable({  stringOrNumber: v.union(v.string(), v.number()),});`

If your table stores multiple different types of documents, you can use `v.union` at the top level:

`defineTable(  v.union(    v.object({      kind: v.literal("StringDocument"),      value: v.string(),    }),    v.object({      kind: v.literal("NumberDocument"),      value: v.number(),    }),  ),);`

In this schema, documents either have a `kind` of `"StringDocument"` and a string for their `value`:

`{  "kind": "StringDocument",  "value": "abc"}`

or they have a `kind` of `"NumberDocument"` and a number for their `value`:

`{  "kind": "NumberDocument",  "value": 123}`

#### Literals[​](https://docs.convex.dev/database/schemas#literals "Direct link to Literals")

Fields that are a constant can be expressed with `v.literal`:

`defineTable({  oneTwoOrThree: v.union(    v.literal("one"),    v.literal("two"),    v.literal("three"),  ),});`

#### Record objects[​](https://docs.convex.dev/database/schemas#record-objects "Direct link to Record objects")

You can describe objects that map arbitrary keys to values with `v.record`:

`defineTable({  simpleMapping: v.record(v.string(), v.boolean()),});`

You can use other types of string validators for the keys:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export default mutation({  args: {    userIdToValue: v.record(v.id("users"), v.boolean()),  },  handler: async ({ db }, { userIdToValue }) => {    //...  },});`

Notes:

*   This type corresponds to the [Record<K,V>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type) type in TypeScript
*   You cannot use string literals as a `record` key
*   Using `v.string()` as a `record` key validator will only allow ASCII characters

#### Any[​](https://docs.convex.dev/database/schemas#any "Direct link to Any")

Fields or documents that could take on any value can be represented with `v.any()`:

`defineTable({  anyValue: v.any(),});`

This corresponds to the `any` type in TypeScript.

### Options[​](https://docs.convex.dev/database/schemas#options "Direct link to Options")

These options are passed as part of the [options](https://docs.convex.dev/api/interfaces/server.DefineSchemaOptions) argument to [`defineSchema`](https://docs.convex.dev/api/modules/server#defineschema).

#### `schemaValidation: boolean`[​](https://docs.convex.dev/database/schemas#schemavalidation-boolean "Direct link to schemavalidation-boolean")

Whether Convex should validate at runtime that your documents match your schema.

By default, Convex will enforce that all new and existing documents match your schema.

You can disable `schemaValidation` by passing in `schemaValidation: false`:

`defineSchema(  {    // Define tables here.  },  {    schemaValidation: false,  },);`

When `schemaValidation` is disabled, Convex will not validate that new or existing documents match your schema. You'll still get schema-specific TypeScript types, but there will be no validation at runtime that your documents match those types.

#### `strictTableNameTypes: boolean`[​](https://docs.convex.dev/database/schemas#stricttablenametypes-boolean "Direct link to stricttablenametypes-boolean")

Whether the TypeScript types should allow accessing tables not in the schema.

By default, the TypeScript table name types produced by your schema are strict. That means that they will be a union of strings (ex. `"messages" | "users"`) and only support accessing tables explicitly listed in your schema.

Sometimes it's useful to only define part of your schema. For example, if you are rapidly prototyping, it could be useful to try out a new table before adding it your `schema.ts` file.

You can disable `strictTableNameTypes` by passing in `strictTableNameTypes: false`:

`defineSchema(  {    // Define tables here.  },  {    strictTableNameTypes: false,  },);`

When `strictTableNameTypes` is disabled, the TypeScript types will allow access to tables not listed in the schema and their document type will be `any`.

Regardless of the value of `strictTableNameTypes`, your schema will only validate documents in the tables listed in the schema. You can still create and modify documents in other tables in JavaScript or on the dashboard (they just won't be validated).

Schemas are pushed automatically in [`npx convex dev`](https://docs.convex.dev/cli#run-the-convex-dev-server) and [`npx convex deploy`](https://docs.convex.dev/cli#deploy-convex-functions-to-production).

The first push after a schema is added or modified will validate that all existing documents match the schema. If there are documents that fail validation, the push will fail.

After the schema is pushed, Convex will validate that all future document inserts and updates match the schema.

Schema validation is skipped if [`schemaValidation`](https://docs.convex.dev/database/schemas#schemavalidation-boolean) is set to `false`.

Note that schemas only validate documents in the tables listed in the schema. You can still create and modify documents in other tables (they just won't be validated).

### Circular references[​](https://docs.convex.dev/database/schemas#circular-references "Direct link to Circular references")

You might want to define a schema with circular ID references like:

convex/schema.ts

`import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  users: defineTable({    preferencesId: v.id("preferences"),  }),  preferences: defineTable({    userId: v.id("users"),  }),});`

In this schema, documents in the `users` table contain a reference to documents in `preferences` and vice versa.

Because schema validation enforces your schema on every `db.insert`, `db.replace`, and `db.patch` call, creating circular references like this is not possible.

The easiest way around this is to make one of the references nullable:

convex/schema.ts

`import { defineSchema, defineTable } from "convex/server";import { v } from "convex/values";export default defineSchema({  users: defineTable({    preferencesId: v.id("preferences"),  }),  preferences: defineTable({    userId: v.union(v.id("users"), v.null()),  }),});`

This way you can create a preferences document first, then create a user document, then set the reference on the preferences document:

`import { mutation } from "./_generated/server";export default mutation({  handler: async (ctx) => {    const preferencesId = await ctx.db.insert("preferences", {});    const userId = await ctx.db.insert("users", { preferencesId });    await ctx.db.patch(preferencesId, { userId });  },});`

[Let us know](https://docs.convex.dev/production/contact) if you need better support for circular references.

Once you've defined a schema, [`npx convex dev`](https://docs.convex.dev/cli#run-the-convex-dev-server) will produce new versions of [`dataModel.d.ts`](https://docs.convex.dev/generated-api/data-model) and [`server.d.ts`](https://docs.convex.dev/generated-api/server) with types based on your schema.

### `Doc<TableName>`[​](https://docs.convex.dev/database/schemas#doctablename "Direct link to doctablename")

The [`Doc`](https://docs.convex.dev/generated-api/data-model#doc) TypeScript type from [`dataModel.d.ts`](https://docs.convex.dev/generated-api/data-model) provides document types for all of your tables. You can use these both when writing Convex functions and in your React components:

MessageView.tsx

`import { Doc } from "../convex/_generated/dataModel";function MessageView(props: { message: Doc<"messages"> }) {  ...}`

If you need the type for a portion of a document, use the [`Infer` type helper](https://docs.convex.dev/functions/validation#extracting-typescript-types).

### `query` and `mutation`[​](https://docs.convex.dev/database/schemas#query-and-mutation "Direct link to query-and-mutation")

The [`query`](https://docs.convex.dev/generated-api/server#query) and [`mutation`](https://docs.convex.dev/generated-api/server#mutation) functions in [`server.js`](https://docs.convex.dev/generated-api/server) have the same API as before but now provide a `db` with more precise types. Functions like [`db.insert(table, document)`](https://docs.convex.dev/api/interfaces/server.GenericDatabaseWriter#insert) now understand your schema. Additionally [database queries](https://docs.convex.dev/database/reading-data/) will now return the correct document type (not `any`).

--- 

Title: Convex Overview | Convex Developer Hub

URL Source: https://docs.convex.dev/understanding/

Markdown Content:
Convex is the open source, reactive database where queries are TypeScript code running right in the database. Just like React components react to state changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex enables. We'll start at the bottom and work our way up to the top of this diagram.

The [database](https://docs.convex.dev/database) is at the core of Convex. The Convex database is automatically provisioned when you create your project. There is no connection setup or cluster management.

The Convex database is reactive. Whenever any data on which a query depends changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like nested objects into your database. "Relational" means you have tables with relations, like `tasks` assigned to a `user` using IDs to reference documents in other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The database is ACID-compliant and uses [serializable isolation and optimistic concurrency control](https://docs.convex.dev/database/advanced/occ). All that to say, Convex provides the strictest possible transactional guarantees, and you never see inconsistent data.

When you create a new Convex project, you automatically get a `convex/` folder where you write your [server functions](https://docs.convex.dev/functions). This is where all your backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to the database.

convex/tasks.ts

`// A Convex query functionexport const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});// A Convex mutation functionexport const setTaskCompleted = mutation({  args: { taskId: v.id("tasks"), completed: v.boolean() },  handler: async (ctx, { taskId, completed }) => {    // Update the database using TypeScript    await ctx.db.patch(taskId, { completed });  },});`

You read and write to your database through query or mutation functions. [Query functions](https://docs.convex.dev/functions/query-functions) are pure functions that can only read from the database. [Mutation functions](https://docs.convex.dev/functions/mutation-functions) are transactions that can read or write from the database. These two database functions are [not allowed to take any non-deterministic](https://docs.convex.dev/functions/runtimes#restrictions-on-queries-and-mutations) actions like network requests to ensure transactional guarantees.

info

The entire Convex mutation function is a transaction. There are no `begin` or `end` transaction statements to write. Convex automatically retries the function on conflicts, and you don't have to manage anything.

Convex also provides standard general-purpose serverless functions called actions. [Action functions](https://docs.convex.dev/functions/actions) can make network requests. They have to call query or mutation functions to read and write to the database. You use actions to call LLMs or send emails.

You can also durably schedule Convex functions via the [scheduler](https://docs.convex.dev/scheduling/scheduled-functions) or [cron jobs](https://docs.convex.dev/scheduling/cron-jobs). Scheduling lets you build workflows like emailing a new user a day later if they haven't performed an onboarding task.

You call your Convex functions via [client libraries](https://docs.convex.dev/client/react) or directly via [HTTP](https://docs.convex.dev/http-api/#functions-api).

Convex client libraries keep your frontend synced with the results of your server functions.

`// In your React componentimport { useQuery } from "convex/react";import { api } from "../convex/_generated/api";export function TaskList() {  const data = useQuery(api.tasks.getAllOpenTasks);  return data ?? "Loading...";}`

Like the `useState` hook that updates your React component when local state changes, the Convex `useQuery` hook automatically updates your component whenever the result of your query changes. There's no manual subscription management or state synchronization needed.

When calling query functions, the client library subscribes to the results of the function. Convex tracks the dependencies of your query functions, including what data was read from the database. Whenever relevant data in the database changes, the Convex automatically reruns the query and sends the result to the client.

The client library also queues up mutations in memory to send to the server. As mutations execute and cause query results to update, the client library keeps your app state consistent. It updates all subscriptions to the same logical moment in time in the database.

Convex provides client libraries for nearly all popular web and native app frameworks. Client libraries connect to your Convex deployment via WebSockets. You can then call your public Convex functions [through the library](https://docs.convex.dev/client/react#fetching-data). You can also use Convex with [HTTP directly](https://docs.convex.dev/http-api/#functions-api), you just won't get the automatic subscriptions.

Let's return to the `getAllOpenTasks` Convex query function from earlier that gets all tasks that are not marked as `completed`:

convex/tasks.ts

`export const getAllOpenTasks = query({  args: {},  handler: async (ctx, args) => {    // Query the database to get all items that are not completed    const tasks = await ctx.db      .query("tasks")      .withIndex("by_completed", (q) => q.eq("completed", false))      .collect();    return tasks;  },});`

Let's follow along what happens when you subscribe to this query:

The web app uses the `useQuery` hook to subscribe to this query, and the following happens to get an initial value:

*   The Convex client sends a message to the Convex server to subscribe to the query
*   The Convex server runs the function, which reads data from the database
*   The Convex server sends a message to the client with the function's result

In this case the initial result looks like this (1):

`[  { _id: "e4g", title: "Grocery shopping", complete: false },  { _id: "u9v", title: "Plant new flowers", complete: false },];`

Then you use a mutation to mark an item as completed (2). Convex then reruns the query (3) to get an updated result. And pushes the result to the web app via the WebSocket connection (4):

`[  { _id: "e4g", title: "Grocery shopping", complete: false },];`

Beyond reactivity, Convex's architecture is crucial for a deeper reason. Convex does not let your app have inconsistent state at any layer of the stack.

To illustrate this, let's imagine you're building a shopping cart for an e-commerce store.

On the product listing page, you have two numbers, one showing the number of items remaining in stock and another showing the number of items in your shopping cart. Each number is a result of a different query function.

Every time you press the "Add to Cart" button, a mutation is called to remove one item from the stock and add it to the shopping cart.

The mutation to change the cart runs in a transaction, so your database is always in a consistent state. The reactive database knows that the queries showing the number of items in stock and the number of items in the shopping cart both need to be updated. The queries are invalidated and rerun. The results are pushed to the web app via the WebSocket connection.

The client library makes sure that both queries update at the same time in the web app since they reflect a singular moment in time in your database. You never have a moment where those numbers don't add up. Your app always shows consistent data.

You can see this example in action in the [Swaghaus sample app](https://swaghaus.biz/).

Convex is designed around a small set of composable abstractions with strong guarantees that result in code that is not only faster to write, it's easier to read and maintain, whether written by a team member or an LLM. Key features make sure you get bug-free AI generated code:

1.   **Queries are Just TypeScript** Your database queries are pure TypeScript functions with end-to-end type safety and IDE support. This means AI can generate database code using the large training set of TypeScript code without switching to SQL.
2.   **Less Code for the Same Work** Since so much infrastructure and boiler plate is automatically manged by Convex there is less code to write, and thus less code to get wrong.
3.   **Automatic Reactivity** The reactive system automatically tracks data dependencies and updates your UI. AI doesn't need to manually manage subscriptions, WebSocket connections, or complex state synchronization—Convex handles all of this automatically.
4.   **Transactional Guarantees** Queries are read-only and mutations run in transactions. These constraints make it nearly impossible for AI to write code that could corrupt your data or leave your app in an inconsistent state.

Together, these features mean AI can focus on your business logic while Convex's guarantees prevent common failure modes.

If you are intrigued about the details of how Convex pulls this all off, you can read Convex co-founder Sujay's excellent [How Convex Works](https://stack.convex.dev/how-convex-works) blog post.

Now that you have a good sense of how Convex fits in your app. Let's walk through the overall workflow of setting up and launching a Convex app.

--- 

Title: Writing Data | Convex Developer Hub

URL Source: https://docs.convex.dev/database/writing-data

Markdown Content:
[Mutations](https://docs.convex.dev/functions/mutation-functions) can insert, update, and remove data from database tables.

You can create new documents in the database with the [`db.insert`](https://docs.convex.dev/api/interfaces/server.GenericDatabaseWriter#insert) method:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const createTask = mutation({  args: { text: v.string() },  handler: async (ctx, args) => {    const taskId = await ctx.db.insert("tasks", { text: args.text });    // do something with `taskId`  },});`

The second argument to `db.insert` is a JavaScript object with data for the new document.

The same types of values that can be passed into and returned from [queries](https://docs.convex.dev/functions/query-functions) and [mutations](https://docs.convex.dev/functions/mutation-functions) can be written into the database. See [Data Types](https://docs.convex.dev/database/types) for the full list of supported types.

The `insert` method returns a globally unique ID for the newly inserted document.

Given an existing document ID the document can be updated using the following methods:

1.   The [`db.patch`](https://docs.convex.dev/api/interfaces/server.GenericDatabaseWriter#patch) method will patch an existing document, shallow merging it with the given partial document. New fields are added. Existing fields are overwritten. Fields set to `undefined` are removed.

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const updateTask = mutation({  args: { id: v.id("tasks") },  handler: async (ctx, args) => {    const { id } = args;    console.log(await ctx.db.get(id));    // { text: "foo", status: { done: true }, _id: ... }    // Add `tag` and overwrite `status`:    await ctx.db.patch(id, { tag: "bar", status: { archived: true } });    console.log(await ctx.db.get(id));    // { text: "foo", tag: "bar", status: { archived: true }, _id: ... }    // Unset `tag` by setting it to `undefined`    await ctx.db.patch(id, { tag: undefined });    console.log(await ctx.db.get(id));    // { text: "foo", status: { archived: true }, _id: ... }  },});`

1.   The [`db.replace`](https://docs.convex.dev/api/interfaces/server.GenericDatabaseWriter#replace) method will replace the existing document entirely, potentially removing existing fields:

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const replaceTask = mutation({  args: { id: v.id("tasks") },  handler: async (ctx, args) => {    const { id } = args;    console.log(await ctx.db.get(id));    // { text: "foo", _id: ... }    // Replace the whole document    await ctx.db.replace(id, { invalid: true });    console.log(await ctx.db.get(id));    // { invalid: true, _id: ... }  },});`

Given an existing document ID the document can be removed from the table with the [`db.delete`](https://docs.convex.dev/api/interfaces/server.GenericDatabaseWriter#delete) method.

`import { mutation } from "./_generated/server";import { v } from "convex/values";export const deleteTask = mutation({  args: { id: v.id("tasks") },  handler: async (ctx, args) => {    await ctx.db.delete(args.id);  },});`

If you are used to SQL you might be looking for some sort of bulk insert or bulk update statement. In Convex the entire `mutation` function is automatically a single transaction.

You can just insert or update in a loop in the mutation function. Convex queues up all database changes in the function and executes them all in a single transaction when the function ends, leading to a single efficient change to the database.

`/** * Bulk insert multiple products into the database. * * Equivalent to the SQL: * ```sql * INSERT INTO products (product_id, product_name, category, price, in_stock) * VALUES *     ('Laptop Pro', 'Electronics', 1299.99, true), *     ('Wireless Mouse', 'Electronics', 24.95, true), *     ('Ergonomic Keyboard', 'Electronics', 89.50, true), *     ('Ultra HD Monitor', 'Electronics', 349.99, false), *     ('Wireless Headphones', 'Audio', 179.99, true); * ``` */export const bulkInsertProducts = mutation({  args: {    products: v.array(      v.object({        product_name: v.string(),        category: v.string(),        price: v.number(),        in_stock: v.boolean(),      }),    ),  },  handler: async (ctx, args) => {    const { products } = args;    // Insert in a loop. This is efficient because Convex queues all the changes    // to be executed in a single transaction when the mutation ends.    for (const product of products) {      const id = await ctx.db.insert("products", {        product_name: product.product_name,        category: product.category,        price: product.price,        in_stock: product.in_stock,      });    }  },});`

Database migrations are done through the migration component. The component is designed to run online migrations to safely evolve your database schema over time. It allows you to resume from failures, and validate changes with dry runs.

To prevent accidental writes of large amounts of records, queries and mutations enforce limits detailed [here](https://docs.convex.dev/production/state/limits#transactions).
</DOCUMENTATION>